<!DOCTYPE html>
<!-- saved from url=(0095)https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/sdk/demos/webkit/SpinningBox.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Spinning WebGL Box</title>

<script type="text/javascript" src="./Spinning WebGL Box_files/webgl-utils.js"></script>
<script type="text/javascript" src="./Spinning WebGL Box_files/webgl-debug.js"></script>
<script src="./Spinning WebGL Box_files/J3DI.js"> </script>
<script src="./Spinning WebGL Box_files/J3DIMath.js" type="text/javascript"> </script>
<!--<script src="./Spinning WebGL Box_files/glMatrix-0.9.5.js" type="text/javascript"> </script>-->
<script src="./Teapot.js" type="text/javascript"> </script>
<script id="vshader" type="x-shader/x-vertex">
    uniform mat4 u_modelViewProjMatrix;
    uniform mat4 u_normalMatrix;
    uniform vec3 lightDir;

    attribute vec3 vNormal;
    attribute vec4 vColor;
    attribute vec4 vPosition;

    varying float v_Dot;
    varying vec4 v_Color;

    void main()
    {
        gl_Position = u_modelViewProjMatrix * vPosition;
        v_Color = vColor;
        vec4 transNormal = u_normalMatrix * vec4(vNormal, 1);
        v_Dot = max(dot(transNormal.xyz, lightDir), 0.0);
    }
</script>

<script id="fshader" type="x-shader/x-fragment">
    precision mediump float;

    varying float v_Dot;
    varying vec4 v_Color;

    void main()
    {
        gl_FragColor = vec4(v_Color.xyz * v_Dot, v_Color.a);
    }
</script>

<script>
    function init()
    {
        // Initialize
        var gl = initWebGL(
            // The id of the Canvas Element
            "example",
            // The ids of the vertex and fragment shaders
            "vshader", "fshader",
            // The vertex attribute names used by the shaders.
            // The order they appear here corresponds to their index
            // used later.
            [ "vNormal", "vColor", "vPosition"],
            // The clear color and depth values
            [ 0, 0, 0, 1 ], 10000);
        if (!gl) {
          return;
        }

        gl.console.log("Starting init...");

        // Set up a uniform variable for the shaders
        gl.uniform3f(gl.getUniformLocation(gl.program, "lightDir"), 0, 0, 1);

        // Create a box. On return 'gl' contains a 'box' property with
        // the BufferObjects containing the arrays for vertices,
        // normals, texture coords, and indices.
        gl.box = makeBox(gl);

        // Set up the array of colors for the cube's faces
        var colors = new Uint8Array(
            [  0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,     // v0-v1-v2-v3 front
               1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,     // v0-v3-v4-v5 right
               0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,     // v0-v5-v6-v1 top
               1, 1, 0, 1,   1, 1, 0, 1,   1, 1, 0, 1,   1, 1, 0, 1,     // v1-v6-v7-v2 left
               1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,     // v7-v4-v3-v2 bottom
               0, 1, 1, 1,   0, 1, 1, 1,   0, 1, 1, 1,   0, 1, 1, 1 ]    // v4-v7-v6-v5 back
                                                );

        // Set up the vertex buffer for the colors
        gl.box.colorObject = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.colorObject);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        // Create some matrices to use later and save their locations in the shaders
        gl.mvMatrix = new J3DIMatrix4();
        gl.u_normalMatrixLoc = gl.getUniformLocation(gl.program, "u_normalMatrix");
        gl.normalMatrix = new J3DIMatrix4();
        gl.u_modelViewProjMatrixLoc =
                gl.getUniformLocation(gl.program, "u_modelViewProjMatrix");
        gl.mvpMatrix = new J3DIMatrix4();

        // Enable all of the vertex attribute arrays.
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
        gl.enableVertexAttribArray(2);

        // Set up all the vertex attributes for vertices, normals and colors
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.vertexObject);
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.normalObject);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.box.colorObject);
        gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, false, 0, 0);
        
        // Bind the index array
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.box.indexObject);

        //loadTeapot(gl);
        
        return gl;
    }

    /*function loadTeapot(gl) {
        //var request = new XMLHttpRequest();
        //request.open("GET", "./Teapot.json");
        //request.onreadystatechange = function() {
        //  if (request.readyState == 4) {
            handleLoadedTeapot(eval(teapotJSON), gl);
        //  }
        //}
        //request.send();
    }
    
    var teapotVertexPositionBuffer;
  var teapotVertexNormalBuffer;
  var teapotVertexTextureCoordBuffer;
  var teapotVertexIndexBuffer;
  function handleLoadedTeapot(teapotData, gl) {
    teapotVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
    teapotVertexNormalBuffer.itemSize = 3;
    teapotVertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

    teapotVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexTextureCoords), gl.STATIC_DRAW);
    teapotVertexTextureCoordBuffer.itemSize = 2;
    teapotVertexTextureCoordBuffer.numItems = teapotData.vertexTextureCoords.length / 2;

    teapotVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
    teapotVertexPositionBuffer.itemSize = 3;
    teapotVertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

    teapotVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(teapotData.indices), gl.STATIC_DRAW);
    teapotVertexIndexBuffer.itemSize = 1;
    teapotVertexIndexBuffer.numItems = teapotData.indices.length;
  }*/
    
    width = -1;
    height = -1;
    var requestId;

    function reshape(gl)
    {
        var canvas = document.getElementById('example');
        var windowWidth = window.innerWidth - 20;
        var windowHeight = window.innerHeight - 40;
        if (windowWidth == width && windowHeight == height)
            return;

        width = windowWidth;
        height = windowHeight;
        canvas.width = width;
        canvas.height = height;

        // Set the viewport and projection matrix for the scene
        gl.viewport(0, 0, width, height);
        gl.perspectiveMatrix = new J3DIMatrix4();
        gl.perspectiveMatrix.perspective(30, width/height, 1, 10000);
        gl.perspectiveMatrix.lookat(0, 0, 7, 0, 0, 0, 0, 1, 0);
    }

    function drawPicture(gl)
    {
        //if(!run)
        //    return;
        
        // Make sure the canvas is sized correctly.
        reshape(gl);

        // Clear the canvas
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Make a model/view matrix.
        gl.mvMatrix.makeIdentity();
        gl.mvMatrix.rotate(pitchAngle, 1,0,0);
        gl.mvMatrix.rotate(yawAngle, 0,1,0);
        gl.mvMatrix.rotate(rollAngle, 0,0,1);
        gl.mvMatrix.rotate(currentAngle, 0,1,0);
//        gl.mvMatrix.translate(0,1,0);

        // Construct the normal matrix from the model-view matrix and pass it in
        gl.normalMatrix.load(gl.mvMatrix);
        gl.normalMatrix.invert();
        gl.normalMatrix.transpose();
        gl.normalMatrix.setUniform(gl, gl.u_normalMatrixLoc, false);

        // Construct the model-view * projection matrix and pass it in
        gl.mvpMatrix.load(gl.perspectiveMatrix);
        gl.mvpMatrix.multiply(gl.mvMatrix);
        gl.mvpMatrix.setUniform(gl, gl.u_modelViewProjMatrixLoc, false);

        // Draw the cube
        gl.drawElements(gl.TRIANGLES, gl.box.numIndices, gl.UNSIGNED_BYTE, 0);
        
        /*
        //Draw the teapot
        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexPositionBuffer);
        gl.vertexAttribPointer(2, teapotVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexTextureCoordBuffer);
        gl.vertexAttribPointer(1, teapotVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, teapotVertexNormalBuffer);
        gl.vertexAttribPointer(0, teapotVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, teapotVertexIndexBuffer);
        gl.mvMatrix.translate(0,1,0);

        // Construct the normal matrix from the model-view matrix and pass it in
        gl.normalMatrix.load(gl.mvMatrix);
        gl.normalMatrix.invert();
        gl.normalMatrix.transpose();
        gl.normalMatrix.setUniform(gl, gl.u_normalMatrixLoc, false);

        // Construct the model-view * projection matrix and pass it in
        gl.mvpMatrix.load(gl.perspectiveMatrix);
        gl.mvpMatrix.multiply(gl.mvMatrix);
        gl.mvpMatrix.setUniform(gl, gl.u_modelViewProjMatrixLoc, false);

        //gl.drawElements(gl.TRIANGLES, teapotVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        */
        // Show the framerate
        framerate.snapshot();

        currentAngle += incAngle;
        if (currentAngle > 360)
            currentAngle -= 360;
            
        if(sendAroundZ)
            pitchAngle++;
        if(pitchAngle > 360)
            pitchAngle -= 360;
        if(sendAroundX)
            yawAngle++;
        if(yawAngle > 360)
            yawAngle -= 360;
    }
    
    function playPause(){
        if(running)
            window.cancelRequestAnimFrame(requestId);
        else
            window.requestAnimFrame(f, c);
        running = !running;
        var btn = document.getElementById("playPauseButton");
        btn.value = running ? "Pause" : "Play";
    }
    
    function setSpeed(){
        incAngle = document.getElementById('speed').value / 10;
    }
    
    function setPitch(){
        pitchAngle = document.getElementById('pitch').value;
    }
    
    function setRoll(){
        rollAngle = document.getElementById('roll').value;
    }
    
    function setYaw(){
        yawAngle = document.getElementById('yaw').value;
    }
    
    function spinCameraAroundZ() {
        sendAroundZ = !sendAroundZ;
        
        var btn = document.getElementById("sendAroundZ");
        btn.value = sendAroundZ ? "Stop spin around Z" : "Start spin around Z";
    }
    
    function spinCameraAroundX() {
        sendAroundX = !sendAroundX;
        
        var btn = document.getElementById("sendAroundX");
        btn.value = sendAroundX ? "Stop spin around X" : "Start spin around X";
    }

    function start()
    {
        c = document.getElementById("example");
        speed = 16;
        var w = Math.floor(window.innerWidth * 0.9);
        var h = Math.floor(window.innerHeight * 0.9);
        running = false;

        //c = WebGLDebugUtils.makeLostContextSimulatingCanvas(c);
        // tell the simulator when to lose context.
        //c.loseContextInNCalls(15);

        c.addEventListener('webglcontextlost', handleContextLost, false);
        c.addEventListener('webglcontextrestored', handleContextRestored, false);

        c.width = w;
        c.height = h;

        var gl = init();
        if (!gl) {
          return;
        }
        //loadTeapot(gl);
        currentAngle = 0;
        incAngle = 0.5;
        pitchAngle = 90;
        rollAngle = 0;
        yawAngle = 0;
        sendAroundZ = false;
        sendAroundX = false;
        
        framerate = new Framerate("framerate");
        f = function() {
            requestId = window.requestAnimFrame(f, c);
            drawPicture(gl);
        };
        //f();
        function handleContextLost(e) {
            gl.console.log("handle context lost");
            e.preventDefault();
            if (requestId !== undefined) {
                window.cancelRequestAnimFrame(requestId);
                requestId = undefined;
            }
        }

        function handleContextRestored() {
            gl.console.log("handle context restored");
            init();
            f();
        }
    }
</script>
<style type="text/css">
    canvas {
        /* border: 2px solid black; */
    }
    .text {
        position:absolute;
        top:100px;
        left:20px;
        font-size:2em;
        color: blue;
    }
</style>
</head>

<body onload="start()">
<canvas id="example" width="1200" height="999">
    If you're seeing this your web browser doesn't support the &lt;canvas&gt;&gt; element. Ouch!
</canvas>
<div id="framerate">Framerate:35fps</div>
<p />
<input type="button" onclick="playPause();" value="Play" id="playPauseButton" />
<input type="button" onclick="spinCameraAroundZ();" value="Spin around Z" id="sendAroundZ" />
<input type="button" onclick="spinCameraAroundX();" value="Spin around X" id="sendAroundX" />
<label id="speed_slider_label" for="slider">Speed: </label>
<input id="speed" type="range" min="1" max="100" value="5" onchange="setSpeed()"/>


<label id="pitch_slider_label" for="slider">Pitch: </label>
<input id="pitch" type="range" min="0" max="90" value="90" onchange="setPitch()"/>

<label id="roll_slider_label" for="slider">Roll: </label>
<input id="roll" type="range" min="0" max="90" value="0" onchange="setRoll()"/>	

<label id="yaw_slider_label" for="slider">Yaw: </label>
<input id="yaw" type="range" min="0" max="90" value="0" onchange="setYaw()"/>			



</body></html>